(** Interpreter for the parse tree generated by the parser.env

Each function maps 1:1 to a kind of parer node and interprets just that
node type. *)

open Parser

(** Holds the current value of each identifier.
    
By the time the interpreter encounters an identifier in the left-hand
side of an assignment, it is assumed to be exist in this map. *)
module TEnv = Map.Make (String)

let rec interpret program = interpret_program TEnv.empty program

and interpret_program env program =
  match program with
  | assignment :: program ->
      let env = interpret_assignment env assignment in
      interpret_program env program
  | _ -> print_env env

and interpret_assignment env (ident, expr) =
  TEnv.add ident (interpret_expr env expr) env

and interpret_expr env (term, expr') =
  interpret_term env term + interpret_expr' env expr'

and interpret_expr' env expr' =
  match expr' with
  | Plus (t, e) -> interpret_term env t + interpret_expr' env e
  | Minus (t, e) -> (interpret_term env t * -1) + interpret_expr' env e
  | EmptyExpr -> 0

and interpret_term env (fact, term') =
  interpret_fact env fact * interpret_term' env term'

and interpret_term' env term' =
  match term' with
  | Mult (f, t) -> interpret_fact env f * interpret_term' env t
  | EmptyTerm -> 1

and interpret_fact env fact =
  match fact with
  | Identifier id -> TEnv.find id env
  | Integer n -> n
  | Expr e -> interpret_expr env e

and print_env env =
  TEnv.iter (fun k v -> print_endline (k ^ " = " ^ string_of_int v)) env
